name: ðŸš€ Deploy to Development

on:
  push:
    branches: [ development ]
  workflow_dispatch:  # Manual trigger
    inputs:
      tag:
        description: 'Image tag (optional)'
        required: false
        default: 'latest'

jobs:
  deploy-dev:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
    environment: development
    steps:
      - uses: actions/checkout@v3
        with:
          fetch-depth: 0

      - name: Set Repository Name
        id: repo_name
        run: |
          # For Docker image
          echo "name=$(echo ${{ github.repository }} | tr '[:upper:]' '[:lower:]')" >> $GITHUB_OUTPUT
          # For artifact name
          echo "artifact_name=$(echo ${{ github.repository }} | tr '[:upper:]' '[:lower:]' | tr '/' '-')" >> $GITHUB_OUTPUT

      - name: Grant execute permission for mvnw
        run: chmod +x mvnw
        
      - name: Set up JDK
        uses: actions/setup-java@v3
        with:
          java-version: '17'
          distribution: 'temurin'
          cache: 'maven'

      - name: SonarQube Scan and Quality Gate
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
          SONAR_PROJECT_KEY: ${{ secrets.SONAR_PROJECT_KEY }}
          SONAR_HOST_URL: ${{ secrets.SONAR_HOST_URL }}
        run: |
          ./mvnw sonar:sonar \
            -Dsonar.projectKey=${{ steps.repo_name.outputs.name }} \
            -Dsonar.host.url=${{ secrets.SONAR_HOST_URL }} \
            -Dsonar.token=${{ secrets.SONAR_TOKEN }}

          # Quality Gate Check
          SONAR_CE_TASK_URL=$(curl -s \
          -u "${{ secrets.SONAR_TOKEN }}:" \
          "${{ secrets.SONAR_HOST_URL }}/api/ce/task?componentKey=${{ secrets.SONAR_PROJECT_KEY }}")

          TASK_ID=$(echo $SONAR_CE_TASK_URL | jq -r '.task.id')

          # Wait for task to complete and get analysis ID
          ANALYSIS_ID=$(curl -s \
          -u "${{ secrets.SONAR_TOKEN }}:" \
          "${{ secrets.SONAR_HOST_URL }}/api/ce/task?id=$TASK_ID" | \
          jq -r '.task.analysisId')

          # Check quality gate status
          QUALITY_GATE_STATUS=$(curl -s \
          -u "${{ secrets.SONAR_TOKEN }}:" \
          "${{ secrets.SONAR_HOST_URL }}/api/qualitygates/project_status?analysisId=$ANALYSIS_ID" | \
          jq -r '.projectStatus.status')

          echo "Quality Gate Status: $QUALITY_GATE_STATUS"

          if [ "$QUALITY_GATE_STATUS" != "OK" ]; then
            echo "âŒ Quality Gate Failed"
            exit 1
          fi

      - name: Create Build Directory
        run: mkdir -p build/quarkus-app/
    
      - name: Download Build Artifact
        id: download
        uses: actions/download-artifact@v3
        with:
          name: ${{ steps.repo_name.outputs.artifact_name }}-build
          path: build/quarkus-app/
        continue-on-error: true  # Continue if no artifact exists

      - name: Set up JDK if no artifact exists
        if: steps.download.outcome == 'failure'
        uses: actions/setup-java@v3
        with:
          java-version: '17'
          distribution: 'temurin'
          cache: 'maven'

      - name: Build if no artifact exists
        if: steps.download.outcome == 'failure'
        run: |
          chmod +x mvnw
          ./mvnw clean package -DskipTests
          # Copy to the correct location for Docker
          mkdir -p build/quarkus-app/
          cp -r target/quarkus-app/* build/quarkus-app/
      
      - name: Generate Version Tag
        id: generate_tag
        run: |
          if [ "${{ github.event_name }}" = "workflow_dispatch" ] && [ "${{ github.event.inputs.tag }}" != "latest" ]; then
            echo "version=${{ github.event.inputs.tag }}" >> $GITHUB_OUTPUT
          else
            echo "version=$(date +'%Y%m%d')-${GITHUB_SHA::7}" >> $GITHUB_OUTPUT
          fi
      
      - name: Login to GitHub Container Registry
        uses: docker/login-action@v2
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Verify Build Directory
        run: |
          echo "Checking build directory contents:"
          ls -la build/quarkus-app/
      
      - name: Build and Push Docker Image
        run: |
          docker build -t ghcr.io/${{ steps.repo_name.outputs.name }}:${{ steps.generate_tag.outputs.version }} .
          docker push ghcr.io/${{ steps.repo_name.outputs.name }}:${{ steps.generate_tag.outputs.version }}
      
      - name: Install OpenShift CLI
        run: |
          curl -LO https://mirror.openshift.com/pub/openshift-v4/clients/ocp/latest/openshift-client-linux.tar.gz
          tar -xvf openshift-client-linux.tar.gz -C /usr/local/bin
          chmod +x /usr/local/bin/oc
        
      - name: Install Helm
        uses: azure/setup-helm@v3
        with:
          version: v3.12.0
        
      - name: Login to OpenShift
        run: |
          oc login --token=${{ secrets.OSC_TOKEN }} --server=${{ secrets.OSC_SERVER }}

      - name: Clone Platform Config
        uses: actions/checkout@v3
        with:
          repository: PTSS-Support/platform-config
          path: platform-config
          token: ${{ secrets.PLATFORM_CONFIG_PAT }}

      - name: Set App Name
        id: app_name
        run: |
          echo "name=$(echo ${{ github.event.repository.name }} | tr '[:upper:]' '[:lower:]' | tr '_' '-')" >> $GITHUB_OUTPUT

      - name: Apply Platform Configs
        run: |
          NAMESPACE=${{ secrets.OSC_DEV_PROJECT }}

          # Apply common configs if they exist and are not empty
          if [ -d "platform-config/common/configmaps" ] && [ "$(ls -A platform-config/common/configmaps)" ]; then
            oc apply -f platform-config/common/configmaps/ -n ${NAMESPACE}
          fi
          if [ -d "platform-config/common/secrets" ] && [ "$(ls -A platform-config/common/secrets)" ]; then
            oc apply -f platform-config/common/secrets/ -n ${NAMESPACE}
          fi

          # Apply app-specific configs if they exist and are not empty
          if [ -d "platform-config/apps/${{ steps.app_name.outputs.name }}/configmaps" ] && [ "$(ls -A platform-config/apps/${{ steps.app_name.outputs.name }}/configmaps)" ]; then
            oc apply -f platform-config/apps/${{ steps.app_name.outputs.name }}/configmaps/ -n ${NAMESPACE}
          fi
          if [ -d "platform-config/apps/${{ steps.app_name.outputs.name }}/secrets" ] && [ "$(ls -A platform-config/apps/${{ steps.app_name.outputs.name }}/secrets)" ]; then
            oc apply -f platform-config/apps/${{ steps.app_name.outputs.name }}/secrets/ -n ${NAMESPACE}
          fi

          # Apply environment-specific common configs
          if [ -d "platform-config/environments/dev/common/configmaps" ] && [ "$(ls -A platform-config/environments/dev/common/configmaps)" ]; then
            oc apply -f platform-config/environments/dev/common/configmaps/ -n ${NAMESPACE}
          fi
          if [ -d "platform-config/environments/dev/common/secrets" ] && [ "$(ls -A platform-config/environments/dev/common/secrets)" ]; then
            oc apply -f platform-config/environments/dev/common/secrets/ -n ${NAMESPACE}
          fi

          # Apply environment-specific app configs
          if [ -d "platform-config/environments/dev/apps/${{ steps.app_name.outputs.name }}/configmaps" ] && [ "$(ls -A platform-config/environments/dev/apps/${{ steps.app_name.outputs.name }}/configmaps)" ]; then
            oc apply -f platform-config/environments/dev/apps/${{ steps.app_name.outputs.name }}/configmaps/ -n ${NAMESPACE}
          fi
          if [ -d "platform-config/environments/dev/apps/${{ steps.app_name.outputs.name }}/secrets" ] && [ "$(ls -A platform-config/environments/dev/apps/${{ steps.app_name.outputs.name }}/secrets)" ]; then
            oc apply -f platform-config/environments/dev/apps/${{ steps.app_name.outputs.name }}/secrets/ -n ${NAMESPACE}
          fi
      
      - name: Deploy to OpenShift Dev
        run: |
          # Create a valid helm release name and route host (lowercase)
          ROUTE_HOST="${{ steps.app_name.outputs.name }}-dev.${{ secrets.APPS_DOMAIN }}"
          
          helm upgrade --install ${{ steps.app_name.outputs.name }} ./helm \
            --namespace ${{ secrets.OSC_DEV_PROJECT }} \
            --values ./helm/values-dev.yaml \
            --set image.registry=ghcr.io \
            --set image.repository=${{ steps.repo_name.outputs.name }} \
            --set image.tag=${{ steps.generate_tag.outputs.version }} \
            --set route.host=${ROUTE_HOST}
              
      - name: Wait for Deployment
        run: |
          oc rollout status deployment/${{ steps.app_name.outputs.name }} -n ${{ secrets.OSC_DEV_PROJECT }} --timeout=180s

      - name: Run E2E Tests
        run: |
          echo "TODO: Add E2E tests using your preferred testing framework"
          echo "These tests should run against the newly deployed dev environment"
  
      - name: Performance Tests (Basic)
        run: |
          echo "TODO: Add basic k6 performance tests against dev environment"
          echo "More extensive performance testing will be done in production deployment"